{
  "hash": "f6b68a4d2501fadd9e6fa13f3bc89bee",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Ten polars functions that pros use and amateurs don't\"\nauthor: '{{< var author >}}'\ndate: '2025-01-13'\ndate-format: iso\ntoc: true\ntoc-title: 'Sections'\ntoc-location: left\ntoc-depth: 2\n---\n\n\n\n\nPolars is increasingly becoming a popular data analysis library, and my prediction is that more new data scientists and analysts will be starting with Polars rather than Pandas as their tool of choice for manipulating data. After all, the syntax for Polars is easier to learn and harder to forget. That's why this tweet couldn't be more true.\n\nHowever, because Polars is new, most of the code out there looks amateurish. Here are 10 functions you should use that will instantly make you look like a pro at Polars.\n\n## 1. Scan CSV\n\nWhen working with large datasets, loading them can take a long time. This is where `scan_csv` becomes useful. Instead of fully reading the dataset, `scan_csv` scans its contents, allowing you to quickly preview the file and select only the columns you need. By loading just a subset of the data, you can significantly reduce the loading time. For example, consider a dataset containing information about counties in the USA.\nimport polars as pl\n\n\n\n::: {#d499b2d4 .cell execution_count=2}\n``` {.python .cell-code}\npl.read_csv(counties_in_the_usa)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3_143, 7)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>region</th><th>population</th><th>county.fips.character</th><th>county.name</th><th>state.name</th><th>state.fips.character</th><th>state.abb</th></tr><tr><td>i64</td><td>i64</td><td>i64</td><td>str</td><td>str</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>1001</td><td>54590</td><td>1001</td><td>&quot;autauga&quot;</td><td>&quot;alabama&quot;</td><td>1</td><td>&quot;AL&quot;</td></tr><tr><td>1003</td><td>183226</td><td>1003</td><td>&quot;baldwin&quot;</td><td>&quot;alabama&quot;</td><td>1</td><td>&quot;AL&quot;</td></tr><tr><td>1005</td><td>27469</td><td>1005</td><td>&quot;barbour&quot;</td><td>&quot;alabama&quot;</td><td>1</td><td>&quot;AL&quot;</td></tr><tr><td>1007</td><td>22769</td><td>1007</td><td>&quot;bibb&quot;</td><td>&quot;alabama&quot;</td><td>1</td><td>&quot;AL&quot;</td></tr><tr><td>1009</td><td>57466</td><td>1009</td><td>&quot;blount&quot;</td><td>&quot;alabama&quot;</td><td>1</td><td>&quot;AL&quot;</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>56037</td><td>43890</td><td>56037</td><td>&quot;sweetwater&quot;</td><td>&quot;wyoming&quot;</td><td>56</td><td>&quot;WY&quot;</td></tr><tr><td>56039</td><td>21326</td><td>56039</td><td>&quot;teton&quot;</td><td>&quot;wyoming&quot;</td><td>56</td><td>&quot;WY&quot;</td></tr><tr><td>56041</td><td>20942</td><td>56041</td><td>&quot;uinta&quot;</td><td>&quot;wyoming&quot;</td><td>56</td><td>&quot;WY&quot;</td></tr><tr><td>56043</td><td>8425</td><td>56043</td><td>&quot;washakie&quot;</td><td>&quot;wyoming&quot;</td><td>56</td><td>&quot;WY&quot;</td></tr><tr><td>56045</td><td>7152</td><td>56045</td><td>&quot;weston&quot;</td><td>&quot;wyoming&quot;</td><td>56</td><td>&quot;WY&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nSuppose you only want to display the county name and population. Here's how you can use `scan_csv` to achieve that:\n\n::: {#f98387ca .cell execution_count=3}\n``` {.python .cell-code}\n(pl.scan_csv(counties_in_the_usa)\n .select('state.name','population')\n .collect()\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3_143, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>state.name</th><th>population</th></tr><tr><td>str</td><td>i64</td></tr></thead><tbody><tr><td>&quot;alabama&quot;</td><td>54590</td></tr><tr><td>&quot;alabama&quot;</td><td>183226</td></tr><tr><td>&quot;alabama&quot;</td><td>27469</td></tr><tr><td>&quot;alabama&quot;</td><td>22769</td></tr><tr><td>&quot;alabama&quot;</td><td>57466</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;wyoming&quot;</td><td>43890</td></tr><tr><td>&quot;wyoming&quot;</td><td>21326</td></tr><tr><td>&quot;wyoming&quot;</td><td>20942</td></tr><tr><td>&quot;wyoming&quot;</td><td>8425</td></tr><tr><td>&quot;wyoming&quot;</td><td>7152</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nNotice that I used `collect` because `scan_csv` produces a lazy frame. This means that whenever you use `scan_csv`, you need to include `collect` at the end to get your results.\n\nIf you're skeptical that `scan_csv` is a better approach, let's compare the time it takes for `scan_csv` and `read_csv` to load the data.\n\n::: {#a815e11d .cell execution_count=4}\n``` {.python .cell-code}\n%%timeit\npl.read_csv(counties_in_the_usa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n106 ms ± 44.5 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n:::\n:::\n\n\n::: {#04458ca6 .cell execution_count=5}\n``` {.python .cell-code}\n%%timeit\npl.scan_csv(counties_in_the_usa)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6.4 μs ± 39.8 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n```\n:::\n:::\n\n\nI'm sure you believe me now.\n\n## 2. Sum horizontal\nAdding values in a single column is easy. All you need is `sum`. This is called column-wise and dataframes shine at performing column-wise mathematical operations. However, there comes a time when you need to perform row-wise calculations. This is where `sum_horizontal` comes in. Unfortunately, most Polars users are not aware of this function. Let's say you had this dataframe for Apple stock data.\n\n::: {#aeed473e .cell execution_count=6}\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (6_953, 7)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Open</th><th>High</th><th>Low</th><th>Close</th><th>Volume</th><th>Adj Close</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>i64</td><td>f64</td></tr></thead><tbody><tr><td>2012-03-30</td><td>608.77</td><td>610.56</td><td>597.94</td><td>599.55</td><td>26050900</td><td>599.55</td></tr><tr><td>2012-03-29</td><td>612.78</td><td>616.56</td><td>607.23</td><td>609.86</td><td>21668300</td><td>609.86</td></tr><tr><td>2012-03-28</td><td>618.38</td><td>621.45</td><td>610.31</td><td>617.62</td><td>23385200</td><td>617.62</td></tr><tr><td>2012-03-27</td><td>606.18</td><td>616.28</td><td>606.06</td><td>614.48</td><td>21628200</td><td>614.48</td></tr><tr><td>2012-03-26</td><td>599.79</td><td>607.15</td><td>595.26</td><td>606.98</td><td>21259900</td><td>606.98</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>1984-09-13</td><td>27.5</td><td>27.62</td><td>27.5</td><td>27.5</td><td>7429600</td><td>3.14</td></tr><tr><td>1984-09-12</td><td>26.87</td><td>27.0</td><td>26.12</td><td>26.12</td><td>4773600</td><td>2.98</td></tr><tr><td>1984-09-11</td><td>26.62</td><td>27.37</td><td>26.62</td><td>26.87</td><td>5444000</td><td>3.07</td></tr><tr><td>1984-09-10</td><td>26.5</td><td>26.62</td><td>25.87</td><td>26.37</td><td>2346400</td><td>3.01</td></tr><tr><td>1984-09-07</td><td>26.5</td><td>26.87</td><td>26.25</td><td>26.5</td><td>2981600</td><td>3.02</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nLets also say that you wanted to create a new column called *sum_OHLC* adds the values in every row for _Open_, _High_, _Low_, _Close_ columns. Most amateur Polars users would write the following code:\n\n::: {#0a124b42 .cell execution_count=7}\n``` {.python .cell-code}\n(apple_stock\n .with_columns(sum_OHLC=pl.col('Open') + pl.col('High') + pl.col('Low') + pl.col('Close'))\n )\n```\n:::\n\n\nThe way to write the above code like a pro is using `sum_horizontal` like this:\n\n::: {#c6d88068 .cell execution_count=8}\n``` {.python .cell-code}\n(apple_stock\n .with_columns(sum_OHLC=pl.sum_horizontal('Open', 'High', 'Low', 'Close'))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (6_953, 8)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Open</th><th>High</th><th>Low</th><th>Close</th><th>Volume</th><th>Adj Close</th><th>sum_OHLC</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>i64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>2012-03-30</td><td>608.77</td><td>610.56</td><td>597.94</td><td>599.55</td><td>26050900</td><td>599.55</td><td>2416.82</td></tr><tr><td>2012-03-29</td><td>612.78</td><td>616.56</td><td>607.23</td><td>609.86</td><td>21668300</td><td>609.86</td><td>2446.43</td></tr><tr><td>2012-03-28</td><td>618.38</td><td>621.45</td><td>610.31</td><td>617.62</td><td>23385200</td><td>617.62</td><td>2467.76</td></tr><tr><td>2012-03-27</td><td>606.18</td><td>616.28</td><td>606.06</td><td>614.48</td><td>21628200</td><td>614.48</td><td>2443.0</td></tr><tr><td>2012-03-26</td><td>599.79</td><td>607.15</td><td>595.26</td><td>606.98</td><td>21259900</td><td>606.98</td><td>2409.18</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>1984-09-13</td><td>27.5</td><td>27.62</td><td>27.5</td><td>27.5</td><td>7429600</td><td>3.14</td><td>110.12</td></tr><tr><td>1984-09-12</td><td>26.87</td><td>27.0</td><td>26.12</td><td>26.12</td><td>4773600</td><td>2.98</td><td>106.11</td></tr><tr><td>1984-09-11</td><td>26.62</td><td>27.37</td><td>26.62</td><td>26.87</td><td>5444000</td><td>3.07</td><td>107.48</td></tr><tr><td>1984-09-10</td><td>26.5</td><td>26.62</td><td>25.87</td><td>26.37</td><td>2346400</td><td>3.01</td><td>105.36</td></tr><tr><td>1984-09-07</td><td>26.5</td><td>26.87</td><td>26.25</td><td>26.5</td><td>2981600</td><td>3.02</td><td>106.12</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nYou not only write shorter code with `sum_horizontal` but you can also use other variations of it like `mean_horizontal` to get the average values of the four numbers and `min_horizontal` to get the smallest number.\n\n## 3. Group by dynamic\n\nWhen working with timeseries data, you may need to resample it based on specific time intervals and perform aggregations. Polars provides a convenient function, `group_by_dynamic`, to handle such tasks efficiently. For example, if you want to calculate the average _Close_ values for Apple stock for each quarter, you can do it as follows:\n\n::: {#3b214f14 .cell execution_count=9}\n``` {.python .cell-code}\n(apple_stock\n .sort('Date')\n .group_by_dynamic('Date', every='1q')\n .agg(pl.mean('Close'))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (111, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Close</th></tr><tr><td>date</td><td>f64</td></tr></thead><tbody><tr><td>1984-07-01</td><td>26.73875</td></tr><tr><td>1984-10-01</td><td>25.288594</td></tr><tr><td>1985-01-01</td><td>26.690968</td></tr><tr><td>1985-04-01</td><td>19.212063</td></tr><tr><td>1985-07-01</td><td>16.015937</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2011-01-01</td><td>345.683226</td></tr><tr><td>2011-04-01</td><td>337.612381</td></tr><tr><td>2011-07-01</td><td>380.510312</td></tr><tr><td>2011-10-01</td><td>391.658571</td></tr><tr><td>2012-01-01</td><td>503.679839</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\n::: {.callout-note}\nBefore using `group_by_dynamic` you must sort the the data on the _Date_ column.  \nEven though my data was already sorted, I still used `sort` to make that explicit.\n:::\n\nThe beauty of `group_by_dynamic` is that it can handle highly granular time intervals. Using the `every` parameter, you can specify intervals such as `\"17d\"` to resample every 17 days, `\"2w\"` for 2 weeks, or even `\"3s\"` for 3-second intervals if your date values include seconds.\n\n## 4. Exclude\n\nIn most cases, you won’t want to display all the columns in your final dataframe—just the ones you’re interested in. To achieve this, you need to remove the unnecessary columns. Many beginners might choose to drop the columns they don’t need, but I strongly recommend using `exclude` instead. \n\nWhat’s the difference between excluding columns and dropping them? Dropping a column requires loading it into memory first, which can be time-consuming, especially with large datasets. On the other hand, excluding a column tells Polars' query engine to skip loading it entirely. This approach is much faster, as Polars only loads the columns you actually need.\n\nHere’s how you can use `exclude`. Suppose you don’t want to load the *Volume* and *Adj Close* columns from the Apple stock dataset. One option is to explicitly select the columns you want to keep, but that would require typing out the names of all five desired columns. Instead, you can use `exclude` to specify just the two columns you don’t want displayed, saving both time and effort.\n\n::: {#ee5d822e .cell execution_count=10}\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (6_953, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Open</th><th>High</th><th>Low</th><th>Close</th></tr><tr><td>str</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>&quot;2012-03-30&quot;</td><td>608.77</td><td>610.56</td><td>597.94</td><td>599.55</td></tr><tr><td>&quot;2012-03-29&quot;</td><td>612.78</td><td>616.56</td><td>607.23</td><td>609.86</td></tr><tr><td>&quot;2012-03-28&quot;</td><td>618.38</td><td>621.45</td><td>610.31</td><td>617.62</td></tr><tr><td>&quot;2012-03-27&quot;</td><td>606.18</td><td>616.28</td><td>606.06</td><td>614.48</td></tr><tr><td>&quot;2012-03-26&quot;</td><td>599.79</td><td>607.15</td><td>595.26</td><td>606.98</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;1984-09-13&quot;</td><td>27.5</td><td>27.62</td><td>27.5</td><td>27.5</td></tr><tr><td>&quot;1984-09-12&quot;</td><td>26.87</td><td>27.0</td><td>26.12</td><td>26.12</td></tr><tr><td>&quot;1984-09-11&quot;</td><td>26.62</td><td>27.37</td><td>26.62</td><td>26.87</td></tr><tr><td>&quot;1984-09-10&quot;</td><td>26.5</td><td>26.62</td><td>25.87</td><td>26.37</td></tr><tr><td>&quot;1984-09-07&quot;</td><td>26.5</td><td>26.87</td><td>26.25</td><td>26.5</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nNow I've loaded into memory only the columns I'm interested in.\n\n## 5. Explode\nImagine you have a dataframe that tracks your weekly grocery purchases, with items listed as comma-separated strings in a single row. If you want to identify the items you buy most frequently, this format poses a challenge. Since Polars is a columnar-based framework, working with such data in its current form can make achieving this goal a bit tricky.\n\n\n\n::: {#1d87beed .cell execution_count=12}\n``` {.python .cell-code}\ngroceries\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (4, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Groceries</th></tr><tr><td>date</td><td>str</td></tr></thead><tbody><tr><td>2024-12-02</td><td>&quot;Milk, Eggs, Corn Flakes, Bacon…</td></tr><tr><td>2024-12-09</td><td>&quot;Bread, Butter, Apples, Oranges…</td></tr><tr><td>2024-12-16</td><td>&quot;Rice, Beans, Chicken, Shampoo,…</td></tr><tr><td>2024-12-23</td><td>&quot;Milk, Eggs, Bananas, Yogurt, S…</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nThis is where `explode` comes in. We'll create a new column _Item_ that will contain a single item as a value for each row. Here's how it works. First we split the data on `\", \"` (comma and space) to convert the string value in _Groceries_ into a list.\n\n::: {#555e9466 .cell execution_count=13}\n``` {.python .cell-code}\n(groceries\n .with_columns(pl.col('Groceries').str.split(', '))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (4, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Groceries</th></tr><tr><td>date</td><td>list[str]</td></tr></thead><tbody><tr><td>2024-12-02</td><td>[&quot;Milk&quot;, &quot;Eggs&quot;, … &quot;Bread&quot;]</td></tr><tr><td>2024-12-09</td><td>[&quot;Bread&quot;, &quot;Butter&quot;, … &quot;Bacon&quot;]</td></tr><tr><td>2024-12-16</td><td>[&quot;Rice&quot;, &quot;Beans&quot;, … &quot;Bacon&quot;]</td></tr><tr><td>2024-12-23</td><td>[&quot;Milk&quot;, &quot;Eggs&quot;, … &quot;Bread&quot;]</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nThen we'll explode the items in each list into individual items by exploding the _Groceries_ column.\n\nThis new format makes it easier to determine the most bought items by counting how many times each item appears in _Groceries_.\n\n::: {#5ee0120f .cell execution_count=14}\n``` {.python .cell-code}\n(groceries\n .with_columns(pl.col('Groceries').str.split(', '))\n .explode('Groceries')\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (27, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Groceries</th></tr><tr><td>date</td><td>str</td></tr></thead><tbody><tr><td>2024-12-02</td><td>&quot;Milk&quot;</td></tr><tr><td>2024-12-02</td><td>&quot;Eggs&quot;</td></tr><tr><td>2024-12-02</td><td>&quot;Corn Flakes&quot;</td></tr><tr><td>2024-12-02</td><td>&quot;Bacon&quot;</td></tr><tr><td>2024-12-02</td><td>&quot;Toothpaste&quot;</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2024-12-23</td><td>&quot;Yogurt&quot;</td></tr><tr><td>2024-12-23</td><td>&quot;Soap&quot;</td></tr><tr><td>2024-12-23</td><td>&quot;Bacon&quot;</td></tr><tr><td>2024-12-23</td><td>&quot;Apples&quot;</td></tr><tr><td>2024-12-23</td><td>&quot;Bread&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## 6. Top / Bottom K\n\nKnowing the top 10 or 5 highest values or lowest values in your dataset is a very common operation. Polars has two handy functions that you can use to easily display that with `top_k` and `bottom_k`. If you wanted to see the top 5 counties in the USA with the highest population, you can use `top_k` see those counties.\n\n::: {#fe9e81cc .cell execution_count=15}\n``` {.python .cell-code}\n(pl.read_csv(counties_in_the_usa)\n .select('county.name','population')\n .top_k(5, by='population')\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>county.name</th><th>population</th></tr><tr><td>str</td><td>i64</td></tr></thead><tbody><tr><td>&quot;los angeles&quot;</td><td>9840024</td></tr><tr><td>&quot;cook&quot;</td><td>5197677</td></tr><tr><td>&quot;harris&quot;</td><td>4101752</td></tr><tr><td>&quot;maricopa&quot;</td><td>3841819</td></tr><tr><td>&quot;san diego&quot;</td><td>3100500</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nThe `top_k` function accepts two parameters: a numerical value specifying the number of rows to display and the column to base the sorting on. For instance, in the example above, we used it to find the top 5 largest counties by population. To find the smallest counties by population, you can simply use the `bottom_k` function instead.\n\n## 7. Sample\n\nWe live in a world of big data and analyzing large datasets can be time-consuming. A smarter approach is to work with a subset of the data, develop and refine your analysis code through experimentation, and then apply the finalized code to the full dataset. But how can you ensure that the subset you choose represents the entire dataset well? This is where the `sample` function comes in. It allows you to randomly select a specified number of rows. Additionally, these selected rows change with each execution, ensuring a different selection every time you run the code.\n\nThe US counties dataset contains over three thousand rows, but we're going to use `sample` to only select a thousand rows.\n\n::: {#04851de5 .cell execution_count=16}\n``` {.python .cell-code}\n(pl.read_csv(counties_in_the_usa)\n .sample(1000)\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (1_000, 7)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>region</th><th>population</th><th>county.fips.character</th><th>county.name</th><th>state.name</th><th>state.fips.character</th><th>state.abb</th></tr><tr><td>i64</td><td>i64</td><td>i64</td><td>str</td><td>str</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>29157</td><td>18986</td><td>29157</td><td>&quot;perry&quot;</td><td>&quot;missouri&quot;</td><td>29</td><td>&quot;MO&quot;</td></tr><tr><td>29027</td><td>44157</td><td>29027</td><td>&quot;callaway&quot;</td><td>&quot;missouri&quot;</td><td>29</td><td>&quot;MO&quot;</td></tr><tr><td>5083</td><td>22352</td><td>5083</td><td>&quot;logan&quot;</td><td>&quot;arkansas&quot;</td><td>5</td><td>&quot;AR&quot;</td></tr><tr><td>13043</td><td>11007</td><td>13043</td><td>&quot;candler&quot;</td><td>&quot;georgia&quot;</td><td>13</td><td>&quot;GA&quot;</td></tr><tr><td>8057</td><td>1397</td><td>8057</td><td>&quot;jackson&quot;</td><td>&quot;colorado&quot;</td><td>8</td><td>&quot;CO&quot;</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>54021</td><td>8623</td><td>54021</td><td>&quot;gilmer&quot;</td><td>&quot;west virginia&quot;</td><td>54</td><td>&quot;WV&quot;</td></tr><tr><td>36077</td><td>62147</td><td>36077</td><td>&quot;otsego&quot;</td><td>&quot;new york&quot;</td><td>36</td><td>&quot;NY&quot;</td></tr><tr><td>19131</td><td>10761</td><td>19131</td><td>&quot;mitchell&quot;</td><td>&quot;iowa&quot;</td><td>19</td><td>&quot;IA&quot;</td></tr><tr><td>6033</td><td>64360</td><td>6033</td><td>&quot;lake&quot;</td><td>&quot;california&quot;</td><td>6</td><td>&quot;CA&quot;</td></tr><tr><td>48375</td><td>121099</td><td>48375</td><td>&quot;potter&quot;</td><td>&quot;texas&quot;</td><td>48</td><td>&quot;TX&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nThe `sample` function lets you specify the number of rows you want to display as a numerical value. In our case, we are displaying 1000 rows.\n\n## 8. Concat str\nThis is short for \"concatenate string\" and it allows you to create a single value which is a mixture of values from 2 or more columns that contain string values. Suppose we wanted to have a column _NameAbbr_ that contains the state name and the abbreviation for that state, we can do it by using `concat_str`.\n\n::: {#588fb9a6 .cell execution_count=17}\n``` {.python .cell-code}\n(pl.read_csv(counties_in_the_usa)\n .select('state.name','state.abb')\n .with_columns(pl.concat_str(['state.name','state.abb'],\n                             separator=', '\n                             ).alias('NameAbbr'))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3_143, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>state.name</th><th>state.abb</th><th>NameAbbr</th></tr><tr><td>str</td><td>str</td><td>str</td></tr></thead><tbody><tr><td>&quot;alabama&quot;</td><td>&quot;AL&quot;</td><td>&quot;alabama, AL&quot;</td></tr><tr><td>&quot;alabama&quot;</td><td>&quot;AL&quot;</td><td>&quot;alabama, AL&quot;</td></tr><tr><td>&quot;alabama&quot;</td><td>&quot;AL&quot;</td><td>&quot;alabama, AL&quot;</td></tr><tr><td>&quot;alabama&quot;</td><td>&quot;AL&quot;</td><td>&quot;alabama, AL&quot;</td></tr><tr><td>&quot;alabama&quot;</td><td>&quot;AL&quot;</td><td>&quot;alabama, AL&quot;</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;wyoming&quot;</td><td>&quot;WY&quot;</td><td>&quot;wyoming, WY&quot;</td></tr><tr><td>&quot;wyoming&quot;</td><td>&quot;WY&quot;</td><td>&quot;wyoming, WY&quot;</td></tr><tr><td>&quot;wyoming&quot;</td><td>&quot;WY&quot;</td><td>&quot;wyoming, WY&quot;</td></tr><tr><td>&quot;wyoming&quot;</td><td>&quot;WY&quot;</td><td>&quot;wyoming, WY&quot;</td></tr><tr><td>&quot;wyoming&quot;</td><td>&quot;WY&quot;</td><td>&quot;wyoming, WY&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nIn the `concat_str` function above, we used two parameters. The first parameter is a list of the columns whose values we want to concatenate, and the second specifies the separator to use when joining those values. In this case, we used `\", \"` (a comma followed by a space) to produce values like \"wyoming, WY\".\n\n## 9. Format\nWhen presenting data to someone, especially in printed form, you may want to add extra details to make the numbers more understandable. For instance, if you're sending the quarterly average Close values you calculated earlier to your boss in the UK and want to add a currency symbol to avoid confusion, you could use `format` to include the dollar symbol. This way, your boss will always know that your analysis was done in dollars.\n\n::: {#480ef25d .cell execution_count=18}\n``` {.python .cell-code}\n(apple_stock\n .sort('Date')\n .group_by_dynamic('Date', every='1q')\n .agg(pl.mean('Close').round(2))\n .with_columns(pl.format(\"${}\", pl.col('Close')).alias('Close'))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (111, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Close</th></tr><tr><td>date</td><td>str</td></tr></thead><tbody><tr><td>1984-07-01</td><td>&quot;$26.74&quot;</td></tr><tr><td>1984-10-01</td><td>&quot;$25.29&quot;</td></tr><tr><td>1985-01-01</td><td>&quot;$26.69&quot;</td></tr><tr><td>1985-04-01</td><td>&quot;$19.21&quot;</td></tr><tr><td>1985-07-01</td><td>&quot;$16.02&quot;</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2011-01-01</td><td>&quot;$345.68&quot;</td></tr><tr><td>2011-04-01</td><td>&quot;$337.61&quot;</td></tr><tr><td>2011-07-01</td><td>&quot;$380.51&quot;</td></tr><tr><td>2011-10-01</td><td>&quot;$391.66&quot;</td></tr><tr><td>2012-01-01</td><td>&quot;$503.68&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\n::: {.callout-note}\nI've used `round` before applying the currency formatting to ensure the figures are rounded to 2 decimal places.\n:::\n\n## 10. Config\nThe default way of displaying polars dataframes is good, but sometimes you may want to change it up a bit like increase the number of rows displayed or increasing the size of a row to see all the values in that row. The function `Config` allows you to do just that. Below is the dataframe of groceries. Currently we cannot see all the values contained in each row as indicated by the ellipsis (...).\n\n::: {#d7d4307f .cell execution_count=19}\n``` {.python .cell-code}\ngroceries\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (4, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Groceries</th></tr><tr><td>date</td><td>str</td></tr></thead><tbody><tr><td>2024-12-02</td><td>&quot;Milk, Eggs, Corn Flakes, Bacon…</td></tr><tr><td>2024-12-09</td><td>&quot;Bread, Butter, Apples, Oranges…</td></tr><tr><td>2024-12-16</td><td>&quot;Rice, Beans, Chicken, Shampoo,…</td></tr><tr><td>2024-12-23</td><td>&quot;Milk, Eggs, Bananas, Yogurt, S…</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nNow Let's use `Config` to increase the size of _Groceries_.\n\n::: {#83f64f19 .cell execution_count=20}\n``` {.python .cell-code}\npl.Config(set_fmt_str_lengths=100)\n\ngroceries\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (4, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Groceries</th></tr><tr><td>date</td><td>str</td></tr></thead><tbody><tr><td>2024-12-02</td><td>&quot;Milk, Eggs, Corn Flakes, Bacon, Toothpaste, Bread&quot;</td></tr><tr><td>2024-12-09</td><td>&quot;Bread, Butter, Apples, Oranges, Cheese, Bacon&quot;</td></tr><tr><td>2024-12-16</td><td>&quot;Rice, Beans, Chicken, Shampoo, Coffee, Eggs, Bacon&quot;</td></tr><tr><td>2024-12-23</td><td>&quot;Milk, Eggs, Bananas, Yogurt, Soap, Bacon, Apples, Bread&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nThe example above demonstrates a global setting, meaning that the next time a dataframe is displayed, it will apply this size to any column whose values don't fit within the default size. This can be frustrating, especially when working with multiple dataframes. To avoid this, you can apply the `Config` setting to display only one dataframe with the desired settings.\n\nLet's display a dataframe showing the county name and population. I'll remove the data types from the columns and add commas as thousand separators to make the population figures easier to read. Additionally, I'll increase the number of rows displayed to 20. Here's how the dataframe initially looks.\n\n::: {#3851d6b6 .cell execution_count=21}\n``` {.python .cell-code}\nusa_counties = (pl.read_csv(counties_in_the_usa)\n .select('county.name','population')\n )\nusa_counties\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3_143, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>county.name</th><th>population</th></tr><tr><td>str</td><td>i64</td></tr></thead><tbody><tr><td>&quot;autauga&quot;</td><td>54590</td></tr><tr><td>&quot;baldwin&quot;</td><td>183226</td></tr><tr><td>&quot;barbour&quot;</td><td>27469</td></tr><tr><td>&quot;bibb&quot;</td><td>22769</td></tr><tr><td>&quot;blount&quot;</td><td>57466</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;sweetwater&quot;</td><td>43890</td></tr><tr><td>&quot;teton&quot;</td><td>21326</td></tr><tr><td>&quot;uinta&quot;</td><td>20942</td></tr><tr><td>&quot;washakie&quot;</td><td>8425</td></tr><tr><td>&quot;weston&quot;</td><td>7152</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nAnd here's the display with the formatting in place.\n\n::: {#cc8c3d8e .cell execution_count=22}\n``` {.python .cell-code}\nwith pl.Config(set_tbl_rows=20,\n               set_tbl_hide_column_data_types=True,\n               set_thousands_separator=True\n               ):\n    display(usa_counties)\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3_143, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>county.name</th><th>population</th></tr></thead><tbody><tr><td>&quot;autauga&quot;</td><td>54,590</td></tr><tr><td>&quot;baldwin&quot;</td><td>183,226</td></tr><tr><td>&quot;barbour&quot;</td><td>27,469</td></tr><tr><td>&quot;bibb&quot;</td><td>22,769</td></tr><tr><td>&quot;blount&quot;</td><td>57,466</td></tr><tr><td>&quot;bullock&quot;</td><td>10,779</td></tr><tr><td>&quot;butler&quot;</td><td>20,730</td></tr><tr><td>&quot;calhoun&quot;</td><td>117,834</td></tr><tr><td>&quot;chambers&quot;</td><td>34,228</td></tr><tr><td>&quot;cherokee&quot;</td><td>25,917</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;niobrara&quot;</td><td>2,478</td></tr><tr><td>&quot;park&quot;</td><td>28,203</td></tr><tr><td>&quot;platte&quot;</td><td>8,677</td></tr><tr><td>&quot;sheridan&quot;</td><td>29,097</td></tr><tr><td>&quot;sublette&quot;</td><td>10,065</td></tr><tr><td>&quot;sweetwater&quot;</td><td>43,890</td></tr><tr><td>&quot;teton&quot;</td><td>21,326</td></tr><tr><td>&quot;uinta&quot;</td><td>20,942</td></tr><tr><td>&quot;washakie&quot;</td><td>8,425</td></tr><tr><td>&quot;weston&quot;</td><td>7,152</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\n::: {.callout-note}\nThe settings applied by `Config` are only for display purposes. When you export the data to Excel or another format, these configurations, such as comma separators in numbers, will be lost.\n:::\n\nCheck out this {{< var polars_course >}} to learn this powerful Python library for data analysis.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}