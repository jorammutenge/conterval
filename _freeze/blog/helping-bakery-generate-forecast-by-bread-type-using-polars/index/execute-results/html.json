{
  "hash": "8bf5e4e92ad59f90784c4aa79e2ae4eb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'How we helped a bakery generate forecast by bread type using polars'\nauthor: '{{< var author >}}'\ndate: '2024-11-18'\nimage: image.png\ndate-format: iso\ntoc: true\ntoc-title: 'Sections'\ntoc-location: left\ntoc-depth: 2\n---\n\n\nA few weeks ago, Conterval did a consulting gig for a medium-sized bakery. This bakery makes white and brown bread, which it sells to a major retail store here in the USA. The bakery contacted our company to help clean up their forecast data and generate a forecast for each bread type.\n\nThe gig turned out to be an interesting experience, so we asked the bakery if I could write about the experience on the company blog, and they said yes. In this post, I'll share what the bakery's problem was and the solution we devised to solve it.\n\n::: {.gray-text .center-text}\n![final forecast output](image.png){fig-align=\"center\"}\n:::\n\n## Problem\n\nThe bakery receives an Excel file with forecast data from a major US retail store every week. This file contains 2 columns: Date (the 1st of every month from January to December) and Forecast (the number of loaves of bread they want in that month).\n\nThe challenge was that the retail store did not provide a separate forecast value for white and brown bread. The retail store just provided a single forecast value. It was up to the bakery to divide that number into how many loaves of white or brown bread to make. It turns out this was a challenging task.\n\n## Solution\n\nCreate a systematic process that determines how many loaves of bread should be made for each bread type based on the provided forecast value for that month. This information should be presented in an easy to understand table.\n\n::: {.callout-note}\nThe generated table should be easy to update based on the new forecast data provided by the retail store.\n:::\n\n## Dataset\n\nWe’ll not use the actual data from the bakery, rather we’ll use fictional data to demonstrate the solution. Here's the baker's sales data from last year.\n\n::: {#989b3dd5 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (24, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th></tr><tr><td>date</td><td>str</td><td>i64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td></tr><tr><td>2023-01-01</td><td>&quot;White&quot;</td><td>203</td></tr><tr><td>2023-02-01</td><td>&quot;Brown&quot;</td><td>329</td></tr><tr><td>2023-02-01</td><td>&quot;White&quot;</td><td>304</td></tr><tr><td>2023-03-01</td><td>&quot;Brown&quot;</td><td>201</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2023-10-01</td><td>&quot;White&quot;</td><td>425</td></tr><tr><td>2023-11-01</td><td>&quot;Brown&quot;</td><td>383</td></tr><tr><td>2023-11-01</td><td>&quot;White&quot;</td><td>297</td></tr><tr><td>2023-12-01</td><td>&quot;Brown&quot;</td><td>248</td></tr><tr><td>2023-12-01</td><td>&quot;White&quot;</td><td>200</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nHere's the forecast data from the retail store.\n\n::: {#9e9a7b94 .cell execution_count=2}\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (12, 2)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Forecast</th></tr><tr><td>date</td><td>i64</td></tr></thead><tbody><tr><td>2024-01-01</td><td>897</td></tr><tr><td>2024-02-01</td><td>945</td></tr><tr><td>2024-03-01</td><td>865</td></tr><tr><td>2024-04-01</td><td>754</td></tr><tr><td>2024-05-01</td><td>1010</td></tr><tr><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2024-08-01</td><td>777</td></tr><tr><td>2024-09-01</td><td>922</td></tr><tr><td>2024-10-01</td><td>848</td></tr><tr><td>2024-11-01</td><td>1002</td></tr><tr><td>2024-12-01</td><td>831</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\n## The math\n\nDetermining how many brown or white loaves of bread to make was not as easy as dividing the forecast value by 2. Why? Because in some months, the retail store buys more white bread than brown bread. In other months, it's the reverse.\n\nWe decided to leverage some timeseries calculations by doing a rolling sum with a 3-months window of last year's sales by bread type. The idea was to get the weight or percentage for each bread type and use that to determine the number of loaves to make from the forecast value.\n\nThis math is quite involving, but it's easy to follow along with the data.\n\n## Implementing the math\nHere are the formulas for calculating the rolling sum for the rows of each bread type.\n\n$$\\text{Row 1} = \\text{Jan} + \\text{Feb} + \\text{Mar}$$\n\n$$\\text{Row 2} = \\text{Feb} + \\text{Mar} + \\text{Apr}$$\n\n$$\\text{...}$$\n\n$$\\text{Second Last Row} = \\text{Nov} + \\text{Dec}$$\n\n$$\\text{Last Row} = \\text{Dec}$$\n\nAnd here is a visualization showing the calculated rolling sum values for each row of brown bread.\n\n\n```{mermaid}\ngraph TD\n    classDef sumStyle fill:#FFE4B5,stroke:#333,stroke-width:2px;\n\n    sum1[\"342 + 329 + 201 = 872\"]:::sumStyle --> sum2[\"329 + 201 + 203 = 733\"]:::sumStyle\n    sum2 --> sum3[\"201 + 203 + 300 = 704\"]:::sumStyle\n    sum3 --> sum4[\"203 + 300 + 473 = 976\"]:::sumStyle\n    sum4 --> sum5[\"300 + 473 + 287 = 1060\"]:::sumStyle\n    sum5 --> sum6[\"473 + 287 + 446 = 1206\"]:::sumStyle\n    sum6 --> sum7[\"287 + 446 + 305 = 1038\"]:::sumStyle\n    sum7 --> sum8[\"446 + 305 + 253 = 1004\"]:::sumStyle\n    sum8 --> sum9[\"305 + 253 + 383 = 941\"]:::sumStyle\n    sum9 --> sum10[\"253 + 383 + 248 = 884\"]:::sumStyle\n    sum10 --> sum11[\"383 + 248 = 631\"]:::sumStyle\n    sum11 --> sum12[\"248\"]:::sumStyle\n```\n\n\nNow that we know what values to expect, we can implement the math. Initially, we thought that doing a `rolling_sum` polars function would perform the calculation shown above but it didn't, at least not entirely.\n\nLet's demonstrate this calculation to see where it fell short.\n\n::: {#142a85f0 .cell execution_count=3}\n``` {.python .cell-code}\n(sales_df\n .filter(pl.col('Bread').eq('Brown'))\n .with_columns(Rol_3month=pl.col('Sales').rolling_sum(window_size=3))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (12, 4)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>i64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>null</td></tr><tr><td>2023-02-01</td><td>&quot;Brown&quot;</td><td>329</td><td>null</td></tr><tr><td>2023-03-01</td><td>&quot;Brown&quot;</td><td>201</td><td>872</td></tr><tr><td>2023-04-01</td><td>&quot;Brown&quot;</td><td>203</td><td>733</td></tr><tr><td>2023-05-01</td><td>&quot;Brown&quot;</td><td>300</td><td>704</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2023-08-01</td><td>&quot;Brown&quot;</td><td>446</td><td>1206</td></tr><tr><td>2023-09-01</td><td>&quot;Brown&quot;</td><td>305</td><td>1038</td></tr><tr><td>2023-10-01</td><td>&quot;Brown&quot;</td><td>253</td><td>1004</td></tr><tr><td>2023-11-01</td><td>&quot;Brown&quot;</td><td>383</td><td>941</td></tr><tr><td>2023-12-01</td><td>&quot;Brown&quot;</td><td>248</td><td>884</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\nThis gives us some of the values we want, but it creates null values for the first 2 rows. To rectify the null value problem on the first two rows, we shifted the values in _Rol_3month_ up by 2 rows. \n\n::: {#4a3ded81 .cell execution_count=4}\n``` {.python .cell-code}\n(sales_df\n .filter(pl.col('Bread').eq('Brown'))\n .with_columns(Rol_3month=pl.col('Sales').rolling_sum(window_size=3))\n .with_columns(Rol_3month_Shift=pl.col('Sales').rolling_sum(window_size=3).shift(-2))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (12, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th><th>Rol_3month_Shift</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>i64</td><td>i64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>null</td><td>872</td></tr><tr><td>2023-02-01</td><td>&quot;Brown&quot;</td><td>329</td><td>null</td><td>733</td></tr><tr><td>2023-03-01</td><td>&quot;Brown&quot;</td><td>201</td><td>872</td><td>704</td></tr><tr><td>2023-04-01</td><td>&quot;Brown&quot;</td><td>203</td><td>733</td><td>976</td></tr><tr><td>2023-05-01</td><td>&quot;Brown&quot;</td><td>300</td><td>704</td><td>1060</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2023-08-01</td><td>&quot;Brown&quot;</td><td>446</td><td>1206</td><td>1004</td></tr><tr><td>2023-09-01</td><td>&quot;Brown&quot;</td><td>305</td><td>1038</td><td>941</td></tr><tr><td>2023-10-01</td><td>&quot;Brown&quot;</td><td>253</td><td>1004</td><td>884</td></tr><tr><td>2023-11-01</td><td>&quot;Brown&quot;</td><td>383</td><td>941</td><td>null</td></tr><tr><td>2023-12-01</td><td>&quot;Brown&quot;</td><td>248</td><td>884</td><td>null</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\nThe problem of null values in the first 2 rows is solved, but another problem is created. The last 2 rows now have null values. At this point, we knew that `rolling_sum` wasn't going to work.\n\nThe reason why rolling sum didn't work is that on the first row, we don't yet have 3 values to add so the sum is null, the same applies to the second row. But on the second row, we have 3 values in the window to add that’s why the first value shows up on row 3.\n\nBut since we wanted the value on row 3 to be on the first row, we shifted the values up by 2 rows, but that only created null values on the bottom two rows. Also, since the rolling sum shifts down one row to get the next 3 values, eventually there won't be enough 3 values to add. That's why we have null values.\n\nHowever, from the formulas above, we see that if there are no 3 values to add, the rolling sum calculation proceeds by calculating the available values. So for the second to last row, it's only 2 values (Nov + Dec), and for the last row, it's only 1 value (Dec).\n\n## Successful implementation of solution\nThe solution that worked involved the use of `implode`. Here's how we implemented it. Let’s focus on brown bread only so we can see that the rolling sum values in the dataframe are the same as those in the visualization.\n\nWe’ll begin by creating a list of all the dates in the sales data.\n\n::: {#21b89213 .cell execution_count=5}\n``` {.python .cell-code}\ndate_list = sales_df['Date'].unique().to_list()\ndate_list\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[datetime.date(2023, 1, 1),\n datetime.date(2023, 2, 1),\n datetime.date(2023, 3, 1),\n datetime.date(2023, 4, 1),\n datetime.date(2023, 5, 1),\n datetime.date(2023, 6, 1),\n datetime.date(2023, 7, 1),\n datetime.date(2023, 8, 1),\n datetime.date(2023, 9, 1),\n datetime.date(2023, 10, 1),\n datetime.date(2023, 11, 1),\n datetime.date(2023, 12, 1)]\n```\n:::\n:::\n\n\n<br>\nNow, let’s write some code to calculate the _Rol_3month_ value for the first date in date_list. This date value will be accessed with 0 index as in `date_list[0]`.\n\n::: {#3eb6dd69 .cell execution_count=6}\n``` {.python .cell-code}\n(sales_df\n .filter(pl.col('Bread').eq('Brown'))\n .with_columns(Sales_List=pl.col('Sales').implode())\n .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n .filter(pl.col('Date').eq(date_list[0]))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (1, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Sales_List</th><th>Rol_3month</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>list[i64]</td><td>i64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>[342, 329, … 248]</td><td>872</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\nIn the code above, we filtered the data to only show brown bread, then created a column _Sales_List_ using `implode`. This stores all sales values from January to December into a single list. To calculate the `Rol_3month`, we slice the list of sales values to only select the first available 3 values and then add them up. Finally, we only get the row in the dataframe that corresponds to the chosen date, which is the first date in *date_list*.\n\nLet’s reuse this code to calculate the _Rol_3month_ value for white bread. Because we want to have a single dataframe showing the results for brown and white bread, we’ll use `vstack` to vertically combine the dataframes.\n\n::: {#bca0a6a1 .cell execution_count=7}\n``` {.python .cell-code}\n(sales_df\n .filter(pl.col('Bread').eq('Brown'))\n .with_columns(Sales_List=pl.col('Sales').implode())\n .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n .filter(pl.col('Date').eq(date_list[0]))\n .vstack(sales_df\n .filter(pl.col('Bread').eq('White'))\n .with_columns(Sales_List=pl.col('Sales').implode())\n .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n .filter(pl.col('Date').eq(date_list[0])))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (2, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Sales_List</th><th>Rol_3month</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>list[i64]</td><td>i64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>[342, 329, … 248]</td><td>872</td></tr><tr><td>2023-01-01</td><td>&quot;White&quot;</td><td>203</td><td>[203, 304, … 200]</td><td>880</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Calculating percentages\n\nHere’s the formula we used to calculate the percentage or weight for each bread type. Let’s focus on brown bread for the month of January.\n\n$$\\% \\text{ of Brown Bread} = \\frac{\\text{January Rol\\_3month}}{\\text{January Rol\\_3month} + \\text{White Bread January Rol\\_3month}}$$\n\nWe are dividing each Rol_3month value for every bread type by the sum of the Rol_3month values for both bread types. Let's put this into code. Also, we don't need *Sales_List*, so we'll drop it.\n\n::: {#91615d23 .cell execution_count=8}\n``` {.python .cell-code}\n(sales_df\n .filter(pl.col('Bread').eq('Brown'))\n .with_columns(Sales_List=pl.col('Sales').implode())\n .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n .filter(pl.col('Date').eq(date_list[0]))\n .drop('Sales_List')\n .vstack(sales_df\n .filter(pl.col('Bread').eq('White'))\n .with_columns(Sales_List=pl.col('Sales').implode())\n .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n .filter(pl.col('Date').eq(date_list[0]))\n .drop('Sales_List'))\n .with_columns(Percentage=pl.col('Rol_3month') / pl.col('Rol_3month').sum())\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (2, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th><th>Percentage</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>i64</td><td>f64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>872</td><td>0.497717</td></tr><tr><td>2023-01-01</td><td>&quot;White&quot;</td><td>203</td><td>880</td><td>0.502283</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nThese are the values we want, but we’ve only calculated for the first date in date_list. We have to perform this calculation for every date in date_list. Rather than doing it manually 12 times, we’ll use a for loop to loop through the date_list.\n\nIt turns out that looping doesn’t work on a list of dates, so we’ll create a list of 12 numbers from 0 to 11. These numbers will be used as indices to represent each date item in date_list. Thus, to use the first date in the list, we use `date_list[0]`.\n\nLet’s create a list of the numbers and store them in a variable called *num_list*.\n\n::: {#a672500f .cell execution_count=9}\n``` {.python .cell-code}\nnum_list = list(range(len(date_list)))\nnum_list\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n```\n:::\n:::\n\n\nNow let’s implement the for loop to get the desired dataframe.\n\n::: {#4bba1633 .cell execution_count=10}\n``` {.python .cell-code}\npct_dfs = []\nfor i in num_list:\n    pct_df = (sales_df\n              .filter(pl.col('Bread').eq('Brown'))\n              .with_columns(Sales_List=pl.col('Sales').implode())\n              .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n              .filter(pl.col('Date').eq(date_list[i]))\n              .drop('Sales_List')\n              .vstack(sales_df\n              .filter(pl.col('Bread').eq('White'))\n              .with_columns(Sales_List=pl.col('Sales').implode())\n              .with_columns(Rol_3month=pl.col('Sales_List').list.slice(0, 3).list.sum())\n              .filter(pl.col('Date').eq(date_list[i]))\n              .drop('Sales_List'))\n              .with_columns(Percentage=pl.col('Rol_3month') / pl.col('Rol_3month').sum())\n              )\n    pct_dfs.append(pct_df)\ndf_with_pct = pl.concat(pct_dfs)\ndf_with_pct\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (24, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th><th>Percentage</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>i64</td><td>f64</td></tr></thead><tbody><tr><td>2023-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>872</td><td>0.497717</td></tr><tr><td>2023-01-01</td><td>&quot;White&quot;</td><td>203</td><td>880</td><td>0.502283</td></tr><tr><td>2023-02-01</td><td>&quot;Brown&quot;</td><td>329</td><td>872</td><td>0.497717</td></tr><tr><td>2023-02-01</td><td>&quot;White&quot;</td><td>304</td><td>880</td><td>0.502283</td></tr><tr><td>2023-03-01</td><td>&quot;Brown&quot;</td><td>201</td><td>872</td><td>0.497717</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2023-10-01</td><td>&quot;White&quot;</td><td>425</td><td>880</td><td>0.502283</td></tr><tr><td>2023-11-01</td><td>&quot;Brown&quot;</td><td>383</td><td>872</td><td>0.497717</td></tr><tr><td>2023-11-01</td><td>&quot;White&quot;</td><td>297</td><td>880</td><td>0.502283</td></tr><tr><td>2023-12-01</td><td>&quot;Brown&quot;</td><td>248</td><td>872</td><td>0.497717</td></tr><tr><td>2023-12-01</td><td>&quot;White&quot;</td><td>200</td><td>880</td><td>0.502283</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Joining forecast data\nTo get the forecast values for each bread type based on percentage values, we must join our dataframe with the forecast data provided by the retail store. We’ll join the dataframes on *Date* column.\n\n::: {.callout-note}\nOur sales data has the year 2023 while the forecast data has the year 2024. This means we won’t be able to join. We have to modify the dates so they match.\n:::\n\nTo make the dates in both dataframes match, we’ll remove the year in the date value. Below is the code that removes the year in the date value for the sales data.\n\n::: {#13ca1f57 .cell execution_count=11}\n``` {.python .cell-code}\n(df_with_pct\n .with_columns(pl.col('Date').dt.strftime('%m-%d'))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (24, 5)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th><th>Percentage</th></tr><tr><td>str</td><td>str</td><td>i64</td><td>i64</td><td>f64</td></tr></thead><tbody><tr><td>&quot;01-01&quot;</td><td>&quot;Brown&quot;</td><td>342</td><td>872</td><td>0.497717</td></tr><tr><td>&quot;01-01&quot;</td><td>&quot;White&quot;</td><td>203</td><td>880</td><td>0.502283</td></tr><tr><td>&quot;02-01&quot;</td><td>&quot;Brown&quot;</td><td>329</td><td>872</td><td>0.497717</td></tr><tr><td>&quot;02-01&quot;</td><td>&quot;White&quot;</td><td>304</td><td>880</td><td>0.502283</td></tr><tr><td>&quot;03-01&quot;</td><td>&quot;Brown&quot;</td><td>201</td><td>872</td><td>0.497717</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;10-01&quot;</td><td>&quot;White&quot;</td><td>425</td><td>880</td><td>0.502283</td></tr><tr><td>&quot;11-01&quot;</td><td>&quot;Brown&quot;</td><td>383</td><td>872</td><td>0.497717</td></tr><tr><td>&quot;11-01&quot;</td><td>&quot;White&quot;</td><td>297</td><td>880</td><td>0.502283</td></tr><tr><td>&quot;12-01&quot;</td><td>&quot;Brown&quot;</td><td>248</td><td>872</td><td>0.497717</td></tr><tr><td>&quot;12-01&quot;</td><td>&quot;White&quot;</td><td>200</td><td>880</td><td>0.502283</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nIn the code below, we remove the year in the forecast data and join the two dataframes in a single dataframe called *combined_df*.\n\n::: {#3e5e59da .cell execution_count=12}\n``` {.python .cell-code}\ncombined_df = (df_with_pct\n .with_columns(pl.col('Date').dt.strftime('%m-%d'))\n .join(forecast_df.with_columns(pl.col('Date').dt.strftime('%m-%d')),\n       on='Date', how='left')\n )\ncombined_df\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (24, 6)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th><th>Percentage</th><th>Forecast</th></tr><tr><td>str</td><td>str</td><td>i64</td><td>i64</td><td>f64</td><td>i64</td></tr></thead><tbody><tr><td>&quot;01-01&quot;</td><td>&quot;Brown&quot;</td><td>342</td><td>872</td><td>0.497717</td><td>897</td></tr><tr><td>&quot;01-01&quot;</td><td>&quot;White&quot;</td><td>203</td><td>880</td><td>0.502283</td><td>897</td></tr><tr><td>&quot;02-01&quot;</td><td>&quot;Brown&quot;</td><td>329</td><td>872</td><td>0.497717</td><td>945</td></tr><tr><td>&quot;02-01&quot;</td><td>&quot;White&quot;</td><td>304</td><td>880</td><td>0.502283</td><td>945</td></tr><tr><td>&quot;03-01&quot;</td><td>&quot;Brown&quot;</td><td>201</td><td>872</td><td>0.497717</td><td>865</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;10-01&quot;</td><td>&quot;White&quot;</td><td>425</td><td>880</td><td>0.502283</td><td>848</td></tr><tr><td>&quot;11-01&quot;</td><td>&quot;Brown&quot;</td><td>383</td><td>872</td><td>0.497717</td><td>1002</td></tr><tr><td>&quot;11-01&quot;</td><td>&quot;White&quot;</td><td>297</td><td>880</td><td>0.502283</td><td>1002</td></tr><tr><td>&quot;12-01&quot;</td><td>&quot;Brown&quot;</td><td>248</td><td>872</td><td>0.497717</td><td>831</td></tr><tr><td>&quot;12-01&quot;</td><td>&quot;White&quot;</td><td>200</td><td>880</td><td>0.502283</td><td>831</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Calculating new forecast\nNow we have all the data needed to calculate the forecast for each bread type. All the forecast values are rounded to the nearest whole number. After all, you cannot make 1.67 loaves of bread!\n\n::: {#af6071c2 .cell execution_count=13}\n``` {.python .cell-code}\nnew_fcst_df = (combined_df\n .with_columns(New_Forecast=(pl.col('Percentage') * pl.col('Forecast')).round().cast(pl.Int16))\n .with_columns(pl.col('Date').add(pl.lit('-2024')).str.strptime(pl.Date, \"%m-%d-%Y\"))\n )\nnew_fcst_df\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (24, 7)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Bread</th><th>Sales</th><th>Rol_3month</th><th>Percentage</th><th>Forecast</th><th>New_Forecast</th></tr><tr><td>date</td><td>str</td><td>i64</td><td>i64</td><td>f64</td><td>i64</td><td>i16</td></tr></thead><tbody><tr><td>2024-01-01</td><td>&quot;Brown&quot;</td><td>342</td><td>872</td><td>0.497717</td><td>897</td><td>446</td></tr><tr><td>2024-01-01</td><td>&quot;White&quot;</td><td>203</td><td>880</td><td>0.502283</td><td>897</td><td>451</td></tr><tr><td>2024-02-01</td><td>&quot;Brown&quot;</td><td>329</td><td>872</td><td>0.497717</td><td>945</td><td>470</td></tr><tr><td>2024-02-01</td><td>&quot;White&quot;</td><td>304</td><td>880</td><td>0.502283</td><td>945</td><td>475</td></tr><tr><td>2024-03-01</td><td>&quot;Brown&quot;</td><td>201</td><td>872</td><td>0.497717</td><td>865</td><td>431</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2024-10-01</td><td>&quot;White&quot;</td><td>425</td><td>880</td><td>0.502283</td><td>848</td><td>426</td></tr><tr><td>2024-11-01</td><td>&quot;Brown&quot;</td><td>383</td><td>872</td><td>0.497717</td><td>1002</td><td>499</td></tr><tr><td>2024-11-01</td><td>&quot;White&quot;</td><td>297</td><td>880</td><td>0.502283</td><td>1002</td><td>503</td></tr><tr><td>2024-12-01</td><td>&quot;Brown&quot;</td><td>248</td><td>872</td><td>0.497717</td><td>831</td><td>414</td></tr><tr><td>2024-12-01</td><td>&quot;White&quot;</td><td>200</td><td>880</td><td>0.502283</td><td>831</td><td>417</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Final output\nWe now have the forecast values for each bread type, but we must present the data in a format that is not only human-readable but also easy to understand. We’ll select the relevant columns and transform the data into the desired format.\n\n::: {#cfe7b1a7 .cell execution_count=14}\n``` {.python .cell-code}\ntable_df = (new_fcst_df\n .select('Date','Bread','New_Forecast')\n .with_columns(pl.col('Date').dt.strftime('%b'))\n .pivot(on='Date', index='Bread')\n )\ntable_df\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (2, 13)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Bread</th><th>Jan</th><th>Feb</th><th>Mar</th><th>Apr</th><th>May</th><th>Jun</th><th>Jul</th><th>Aug</th><th>Sep</th><th>Oct</th><th>Nov</th><th>Dec</th></tr><tr><td>str</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td><td>i16</td></tr></thead><tbody><tr><td>&quot;Brown&quot;</td><td>446</td><td>470</td><td>431</td><td>375</td><td>503</td><td>373</td><td>478</td><td>387</td><td>459</td><td>422</td><td>499</td><td>414</td></tr><tr><td>&quot;White&quot;</td><td>451</td><td>475</td><td>434</td><td>379</td><td>507</td><td>377</td><td>482</td><td>390</td><td>463</td><td>426</td><td>503</td><td>417</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nThis format is better, but since at Conterval we’re sticklers for aesthetics, we decided to make the final forecast output look even better. To do this, we used a library called `great-tables`.\n\n::: {#ad8af1a9 .cell execution_count=15}\n``` {.python .cell-code}\nfrom great_tables import GT, style, loc, google_font, html\n\nmonth_list = table_df.columns[1:]\ncol_spacing = {month: '60px' for month in month_list}\n\n(\n    GT(table_df, rowname_col=\"Bread\")\n    .tab_stubhead(label=html('<b>Bread'))\n    .tab_header(title=html(\"<h2>Bread Types Forecast 2024</h2>\"))\n    .tab_options(\n        table_background_color='#ffbe6f',\n        row_group_font_weight='bold'\n    )\n    .tab_style(\n        style=style.text(weight='bold', font=google_font(name=\"Fjalla One\")),\n        locations=loc.column_header()\n    )\n    .cols_width(cases=col_spacing)\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div id=\"qqldeazfez\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>\n@import url('https://fonts.googleapis.com/css2?family=Fjalla+One&display=swap');\n#qqldeazfez table {\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n          -webkit-font-smoothing: antialiased;\n          -moz-osx-font-smoothing: grayscale;\n        }\n\n#qqldeazfez thead, tbody, tfoot, tr, td, th { border-style: none; }\n tr { background-color: transparent; }\n#qqldeazfez p { margin: 0; padding: 0; }\n #qqldeazfez .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #ffbe6f; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; }\n #qqldeazfez .gt_caption { padding-top: 4px; padding-bottom: 4px; }\n #qqldeazfez .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #ffbe6f; border-bottom-width: 0; }\n #qqldeazfez .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #ffbe6f; border-top-width: 0; }\n #qqldeazfez .gt_heading { background-color: #ffbe6f; text-align: center; border-bottom-color: #ffbe6f; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; }\n #qqldeazfez .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; }\n #qqldeazfez .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; }\n #qqldeazfez .gt_col_heading { color: #333333; background-color: #ffbe6f; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; }\n #qqldeazfez .gt_column_spanner_outer { color: #333333; background-color: #ffbe6f; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; }\n #qqldeazfez .gt_column_spanner_outer:first-child { padding-left: 0; }\n #qqldeazfez .gt_column_spanner_outer:last-child { padding-right: 0; }\n #qqldeazfez .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; }\n #qqldeazfez .gt_spanner_row { border-bottom-style: hidden; }\n #qqldeazfez .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #ffbe6f; font-size: 100%; font-weight: bold; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; }\n #qqldeazfez .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #ffbe6f; font-size: 100%; font-weight: bold; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; }\n #qqldeazfez .gt_from_md> :first-child { margin-top: 0; }\n #qqldeazfez .gt_from_md> :last-child { margin-bottom: 0; }\n #qqldeazfez .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; }\n #qqldeazfez .gt_stub { color: #333333; background-color: #ffbe6f; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; }\n #qqldeazfez .gt_stub_row_group { color: #333333; background-color: #ffbe6f; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; }\n #qqldeazfez .gt_row_group_first td { border-top-width: 2px; }\n #qqldeazfez .gt_row_group_first th { border-top-width: 2px; }\n #qqldeazfez .gt_striped { background-color: rgba(128,128,128,0.05); }\n #qqldeazfez .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; }\n #qqldeazfez .gt_sourcenotes { color: #333333; background-color: #ffbe6f; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; }\n #qqldeazfez .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; text-align: left; }\n #qqldeazfez .gt_left { text-align: left; }\n #qqldeazfez .gt_center { text-align: center; }\n #qqldeazfez .gt_right { text-align: right; font-variant-numeric: tabular-nums; }\n #qqldeazfez .gt_font_normal { font-weight: normal; }\n #qqldeazfez .gt_font_bold { font-weight: bold; }\n #qqldeazfez .gt_font_italic { font-style: italic; }\n #qqldeazfez .gt_super { font-size: 65%; }\n #qqldeazfez .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; }\n #qqldeazfez .gt_asterisk { font-size: 100%; vertical-align: 0; }\n \n</style>\n<table style=\"table-layout: fixed;\" class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n<colgroup>\n  <col/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n  <col style=\"width:60px;\"/>\n</colgroup>\n\n<thead>\n\n  <tr class=\"gt_heading\">\n    <td colspan=\"13\" class=\"gt_heading gt_title gt_font_normal\"><h2>Bread Types Forecast 2024</h2></td>\n  </tr>\n<tr class=\"gt_col_headings\">\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;b&gt;Bread\"><b>Bread</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Jan\">Jan</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Feb\">Feb</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Mar\">Mar</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Apr\">Apr</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"May\">May</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Jun\">Jun</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Jul\">Jul</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Aug\">Aug</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Sep\">Sep</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Oct\">Oct</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Nov\">Nov</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"font-family: Fjalla One;font-weight: bold;\" scope=\"col\" id=\"Dec\">Dec</th>\n</tr>\n</thead>\n<tbody class=\"gt_table_body\">\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">Brown</th>\n    <td class=\"gt_row gt_right\">446</td>\n    <td class=\"gt_row gt_right\">470</td>\n    <td class=\"gt_row gt_right\">431</td>\n    <td class=\"gt_row gt_right\">375</td>\n    <td class=\"gt_row gt_right\">503</td>\n    <td class=\"gt_row gt_right\">373</td>\n    <td class=\"gt_row gt_right\">478</td>\n    <td class=\"gt_row gt_right\">387</td>\n    <td class=\"gt_row gt_right\">459</td>\n    <td class=\"gt_row gt_right\">422</td>\n    <td class=\"gt_row gt_right\">499</td>\n    <td class=\"gt_row gt_right\">414</td>\n  </tr>\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">White</th>\n    <td class=\"gt_row gt_right\">451</td>\n    <td class=\"gt_row gt_right\">475</td>\n    <td class=\"gt_row gt_right\">434</td>\n    <td class=\"gt_row gt_right\">379</td>\n    <td class=\"gt_row gt_right\">507</td>\n    <td class=\"gt_row gt_right\">377</td>\n    <td class=\"gt_row gt_right\">482</td>\n    <td class=\"gt_row gt_right\">390</td>\n    <td class=\"gt_row gt_right\">463</td>\n    <td class=\"gt_row gt_right\">426</td>\n    <td class=\"gt_row gt_right\">503</td>\n    <td class=\"gt_row gt_right\">417</td>\n  </tr>\n</tbody>\n\n\n</table>\n\n</div>\n        \n```\n:::\n:::\n\n\n<br>\n\nContact us for help with your data problems. Also check out our {{< var polars_course >}} to level up your data analysis skills with this fast Python library.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}