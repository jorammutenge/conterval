{
  "hash": "0bdc1b78707ff227b71d7af9a9be88b0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Tranforming timeseries data with group by and group by dynamic in polars'\nauthor: '{{< var author >}}'\ndate: '2025-01-06'\ndate-format: iso\ntoc: true\ntoc-title: 'Sections'\ntoc-location: right\ntoc-depth: 3\nimage: image.jpg\n---\n\n\n\n\n::: {.gray-text .center-text}\n![a brand of yogurt](image.jpg){fig-align=\"center\" width=90%}\n:::\n\nPolars has become my go-to library for data analysis. Each client project brings new insights into the powerful functionality Polars offers. Recently, I worked on a project for a supermarket that required processing data related to yogurt stock quantities.\n\n## The problem\n\nThe supermarket's data included multiple quantity entries for the same yogurt brand within a single month. The goal was to aggregate these quantities into a single value per month and standardize the date to the first day of that month. \n\nFor example, the data for a yogurt brand like Chobani in February might look like this:\n\n- Feb-02-2025 = 30 units  \n- Feb-08-2025 = 20 units  \n- Feb-15-2025 = 50 units  \n\nThe desired output for February would aggregate these values into:\n\n- Feb-01-2025 = 100 units  \n\nThis aggregation needed to be repeated for every yogurt brand sold by the supermarket.\n\n## The dataset\n\nTo demonstrate how I solved this problem, I’ll use a representative dataset (not the actual client data).\n\n::: {#b120f612 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (49, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Yogurt</th><th>Quantity</th></tr><tr><td>date</td><td>str</td><td>i64</td></tr></thead><tbody><tr><td>2025-02-05</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-11</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-14</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-19</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-26</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2025-06-03</td><td>&quot;Wallaby Organic&quot;</td><td>48</td></tr><tr><td>2025-06-03</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-06-03</td><td>&quot;Chobani&quot;</td><td>120</td></tr><tr><td>2025-06-23</td><td>&quot;Dannon&quot;</td><td>12</td></tr><tr><td>2025-06-24</td><td>&quot;Chobani&quot;</td><td>120</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## The solution\n\nI’ll show two approaches to solving this problem. The first method uses `group_by`, while the second uses `group_by_dynamic`. Afterward, I’ll verify that both methods produce identical results. More importantly, I’ll compare their performance by using the `%%timeit` cell magic command to identify the faster solution.\n\n### Solution with group by dynamic\n\nWhen resampling time series data, `group_by_dynamic` simplifies selecting a specific time period (e.g., weekly, monthly, quarterly) and resampling the data to perform aggregations based on the chosen interval. However, `group_by_dynamic` does not support grouping by multiple columns. While this limitation may make it unsuitable for addressing the client's problem directly, a workaround is available.\n\nLet's process the data for a single yogurt brand, Yoplait to see if the solution is working the way we expect it. Then we'll repeat the process for all yogurt brands. Here's is the unprocessed data for Yoplait yogurt.\n\n::: {#83e6ec5c .cell execution_count=2}\n``` {.python .cell-code}\ndata.filter(pl.col('Yogurt') == \"Yoplait\")\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (18, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Yogurt</th><th>Quantity</th></tr><tr><td>date</td><td>str</td><td>i64</td></tr></thead><tbody><tr><td>2025-02-05</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-11</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-14</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-19</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-02-26</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2025-04-30</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-05-09</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-05-16</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-05-26</td><td>&quot;Yoplait&quot;</td><td>54</td></tr><tr><td>2025-06-03</td><td>&quot;Yoplait&quot;</td><td>54</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nHere is the processed data for Yoplait yogurt. The aggregations have been completed, resulting in a reduced number of rows in the dataframe.\n\n::: {#1802512e .cell execution_count=3}\n``` {.python .cell-code}\n(data\n .filter(pl.col('Yogurt') == \"Yoplait\")\n .group_by_dynamic('Date', every='1mo')\n .agg(pl.sum('Quantity'), pl.first('Yogurt'))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Quantity</th><th>Yogurt</th></tr><tr><td>date</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>2025-02-01</td><td>270</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-03-01</td><td>270</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-04-01</td><td>216</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-05-01</td><td>162</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-06-01</td><td>54</td><td>&quot;Yoplait&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\nNotice that I have selected a 1-month time period for the `every` parameter. However, there is an unresolved issue in our solution: we have multiple dates instead of a single date representing the first day of each month. To address this, I will introduce another parameter, `start_by`, and set its value to `\"window\"`. This ensures that all dates are converted to the first day of their respective months.\n\n::: {#65ae87ba .cell execution_count=4}\n``` {.python .cell-code}\n(data\n .filter(pl.col('Yogurt') == \"Yoplait\")\n .group_by_dynamic('Date', every='1mo', start_by='window')\n .agg(pl.sum('Quantity'), pl.first('Yogurt'))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Quantity</th><th>Yogurt</th></tr><tr><td>date</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>2025-02-01</td><td>270</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-03-01</td><td>270</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-04-01</td><td>216</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-05-01</td><td>162</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-06-01</td><td>54</td><td>&quot;Yoplait&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\nHaving achieved the desired results for Yoplait yogurt, I can now process the data for the other brands. Instead of processing each brand individually, I will use a `for` loop to automate the task.\n\nFirst, I'll create a list of all the yogurt brands contained in the dataset.\n\n::: {#8cb25aff .cell execution_count=5}\n``` {.python .cell-code}\nyogurt_list = data['Yogurt'].unique().to_list()\nyogurt_list\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n['Chobani',\n 'Activia',\n 'Fage',\n 'Stonyfield Organic',\n 'Brown Cow',\n 'Yoplait',\n 'Wallaby Organic',\n 'Noosa',\n \"Siggi's\",\n 'Oikos',\n 'Dannon']\n```\n:::\n:::\n\n\nAnd now here's the code that implements the `for` loop.\n\n::: {#94609b7f .cell execution_count=6}\n``` {.python .cell-code}\ndfs = []\nfor item in yogurt_list:\n    df = (data\n    .filter(pl.col('Yogurt') == item)\n    .group_by_dynamic('Date', every='1mo', start_by='window')\n    .agg(pl.sum('Quantity'), pl.first('Yogurt'))\n    )\n    dfs.append(df)\ndf_1 = pl.concat(dfs)\ndf_1\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (23, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Quantity</th><th>Yogurt</th></tr><tr><td>date</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>2025-03-01</td><td>444</td><td>&quot;Chobani&quot;</td></tr><tr><td>2025-04-01</td><td>240</td><td>&quot;Chobani&quot;</td></tr><tr><td>2025-05-01</td><td>408</td><td>&quot;Chobani&quot;</td></tr><tr><td>2025-06-01</td><td>240</td><td>&quot;Chobani&quot;</td></tr><tr><td>2025-05-01</td><td>504</td><td>&quot;Activia&quot;</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>2025-05-01</td><td>12</td><td>&quot;Noosa&quot;</td></tr><tr><td>2025-04-01</td><td>6</td><td>&quot;Siggi&#x27;s&quot;</td></tr><tr><td>2025-04-01</td><td>144</td><td>&quot;Oikos&quot;</td></tr><tr><td>2025-05-01</td><td>144</td><td>&quot;Oikos&quot;</td></tr><tr><td>2025-06-01</td><td>12</td><td>&quot;Dannon&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nTo verify that the above code worked correctly, let display the results for Yoplait yogurt.\n\n::: {#6f54978e .cell execution_count=7}\n``` {.python .cell-code}\ndf_1.filter(pl.col('Yogurt') == \"Yoplait\")\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Date</th><th>Quantity</th><th>Yogurt</th></tr><tr><td>date</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>2025-02-01</td><td>270</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-03-01</td><td>270</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-04-01</td><td>216</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-05-01</td><td>162</td><td>&quot;Yoplait&quot;</td></tr><tr><td>2025-06-01</td><td>54</td><td>&quot;Yoplait&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nGreat! The results are what we expected.\n\n### Solution with group by\n\nFortunately, with `group_by`, it is possible to aggregate data across multiple columns. This allows me to process the data for all yogurt brands without using a `for` loop. However, I first need to create a new column, _Month_, to use as one of the grouping columns in `group_by`. As before, I will start by processing the data for a single yogurt brand, Yoplait.\n\n::: {#0171bdfe .cell execution_count=8}\n``` {.python .cell-code}\n(data\n .filter(pl.col('Yogurt') == \"Yoplait\")\n .with_columns(Month=pl.col('Date').dt.month())\n .group_by('Yogurt','Month')\n .agg(pl.sum('Quantity'),\n       pl.first('Date'))\n .drop('Month')\n .with_columns(pl.col(\"Date\").dt.truncate(\"1mo\"))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Yogurt</th><th>Quantity</th><th>Date</th></tr><tr><td>str</td><td>i64</td><td>date</td></tr></thead><tbody><tr><td>&quot;Yoplait&quot;</td><td>270</td><td>2025-03-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>54</td><td>2025-06-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>216</td><td>2025-04-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>270</td><td>2025-02-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>162</td><td>2025-05-01</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n<br>\n\nNotice that I have used two columns, _Yogurt_ and _Month_, in `group_by` to aggregate quantities based on this two-column combination. Since _Month_ has served its purpose, I can drop it as it is no longer needed. However, the date values are not in the expected format. To resolve this issue, I will use `truncate` and set the value to `\"1mo\"` to adjust the values in the _Date_ column by one month.\n\n::: {#f5186274 .cell execution_count=9}\n``` {.python .cell-code}\n(data\n .filter(pl.col('Yogurt') == \"Yoplait\")\n .with_columns(Month=pl.col('Date').dt.month())\n .group_by('Yogurt','Month')\n .agg(pl.sum('Quantity'),\n       pl.first('Date'))\n .drop('Month')\n .with_columns(pl.col(\"Date\").dt.truncate(\"1mo\"))\n )\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Yogurt</th><th>Quantity</th><th>Date</th></tr><tr><td>str</td><td>i64</td><td>date</td></tr></thead><tbody><tr><td>&quot;Yoplait&quot;</td><td>270</td><td>2025-03-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>216</td><td>2025-04-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>162</td><td>2025-05-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>270</td><td>2025-02-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>54</td><td>2025-06-01</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nNow that we have the expected results, all that’s left to process the data for all yogurt brands is to remove the line of code containing `filter`.\n\n::: {#a82e1cbf .cell execution_count=10}\n``` {.python .cell-code}\ndf_2 = (data\n .with_columns(Month=pl.col('Date').dt.month())\n .group_by('Yogurt','Month')\n .agg(pl.sum('Quantity'),\n       pl.first('Date'))\n .drop('Month')\n .with_columns(pl.col(\"Date\").dt.truncate(\"1mo\"))\n )\ndf_2\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (23, 3)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>Yogurt</th><th>Quantity</th><th>Date</th></tr><tr><td>str</td><td>i64</td><td>date</td></tr></thead><tbody><tr><td>&quot;Oikos&quot;</td><td>144</td><td>2025-05-01</td></tr><tr><td>&quot;Chobani&quot;</td><td>408</td><td>2025-05-01</td></tr><tr><td>&quot;Chobani&quot;</td><td>240</td><td>2025-04-01</td></tr><tr><td>&quot;Stonyfield Organic&quot;</td><td>60</td><td>2025-04-01</td></tr><tr><td>&quot;Fage&quot;</td><td>24</td><td>2025-05-01</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>&quot;Noosa&quot;</td><td>12</td><td>2025-03-01</td></tr><tr><td>&quot;Oikos&quot;</td><td>144</td><td>2025-04-01</td></tr><tr><td>&quot;Chobani&quot;</td><td>444</td><td>2025-03-01</td></tr><tr><td>&quot;Yoplait&quot;</td><td>162</td><td>2025-05-01</td></tr><tr><td>&quot;Wallaby Organic&quot;</td><td>192</td><td>2025-06-01</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n## Comparing the two methods\n\nMultiple factors can be used to determine which code is better, such as ease of writing. However, I will focus on determining which code processes the data faster. Let's test which approach performs better.\n\n**With group by dynamic**\n\n::: {#844af2e1 .cell execution_count=11}\n``` {.python .cell-code}\n%%timeit\n\ndfs = []\nfor item in yogurt_list:\n    df = (data\n    .filter(pl.col('Yogurt') == item)\n    .group_by_dynamic('Date', every='1mo', start_by='window')\n    .agg(pl.sum('Quantity'), pl.first('Yogurt'))\n    )\n    dfs.append(df)\ndf_1 = pl.concat(dfs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.12 ms ± 6.42 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n```\n:::\n:::\n\n\n**With group by**\n\n::: {#4c61c630 .cell execution_count=12}\n``` {.python .cell-code}\n%%timeit\n\n(data\n .with_columns(Month=pl.col('Date').dt.month())\n .group_by('Yogurt','Month')\n .agg(pl.sum('Quantity'),\n       pl.first('Date'))\n .drop('Month')\n .with_columns(pl.col(\"Date\").dt.truncate(\"1mo\"))\n )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n253 μs ± 1.67 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n```\n:::\n:::\n\n\nYou can see that `group_by` processes the data faster, making it the better method. This isn't surprising, actually, because it doesn't involve using a `for` loop. It's always better to avoid loops when working with dataframes, as this allows your code to be executed in Rust, the language in which Polars was written. When you use `for` loops, your code is executed in Python, which is slower than Rust.\n\nCheck out the new {{< var finance_course >}} we published to learn how to process and analyze stock data.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}